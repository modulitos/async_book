use async_book::executor::new_executor_and_spawner;
use futures::future::Future;

// This function:
async fn foo(x: &u8) -> u8 {
    *x
}

// Is equivalent to this function:
fn foo_expanded<'a>(x: &'a u8) -> impl Future<Output = u8> + 'a {
    async move { *x }
}

/// `async` block:
///
/// Multiple different `async` blocks can access the same local variable
/// so long as they're executed within the variable's scope
async fn blocks() {
    let my_string = "foo".to_string();

    let future_one = async {
        // ...
        println!("{}", my_string);
    };

    let future_two = async {
        // ...
        println!("{}", my_string);
    };

    // Run both futures to completion, printing "foo" twice:
    let ((), ()) = futures::join!(future_one, future_two);
}

/// `async move` block:
///
/// Only one `async move` block can access the same captured variable, since
/// captures are moved into the `Future` generated by the `async move` block.
/// However, this allows the `Future` to outlive the original scope of the
/// variable:
fn move_block() -> impl Future<Output = ()> {
    let my_string = "foo move".to_string();
    async move {
        println!("{}", my_string);
    }
}

fn main() {
    let (executor, spawner) = new_executor_and_spawner();

    spawner.spawn(async {
        println!("starting!");
        // let mut future = None;
        let x = 11;

        // If we move this line above, then `future` will have a longer lifetime than `x`, and we'll
        // get a compiler error! So we have to ensure that we .await the future while the non-static
        // arguments are still valid.

        let mut future = None;
        future = Some(foo(&x));
        let output = future.unwrap().await;
        println!("output: {}", output);

        // test our async block which joins 2 futures:
        blocks().await;
        // test our async move block:
        move_block().await;

    });

    drop(spawner);
    executor.run();
}
